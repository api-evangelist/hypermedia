{"tools":[{"id":"134","name":"ALPS - Application-Level Profile Semantics","summary":"The purpose of Application-Level Profile Semantics (ALPS) is to document the application-level semantics of a particular implementation. This is accomplished by describing elements of response representations for a target media type. For example identifying markup elements returned (i.e. semantic HTML ala Microformats) and state transitions (i.e. HTML.A and HTML.FORM elements) that advance the sta","details":"The purpose of Application-Level Profile Semantics (ALPS) is to document the application-level semantics of a particular implementation. This is accomplished by describing elements of response representations for a target media type. For example identifying markup elements returned (i.e. semantic HTML ala Microformats) and state transitions (i.e. HTML.A and HTML.FORM elements) that advance the state of the current application.","website":"http:\/\/amundsen.com\/hypermedia\/profiles\/","logo":"http:\/\/kinlane-productions.s3.amazonaws.com\/api-evangelist-site\/blog\/mca-icon-e.jpg","width":"100","tags":"API Design,Hypermedia"},{"id":"155","name":"Collection+JSON","summary":"Collection+JSON is a JSON-based read\/write hypermedia-type designed to support management and querying of simple collections.","details":"Collection+JSON is a JSON-based read\/write hypermedia-type designed to support management and querying of simple collections.","website":"http:\/\/amundsen.com\/media-types\/collection\/","logo":"http:\/\/kinlane-productions.s3.amazonaws.com\/api-evangelist-site\/blog\/madmen_icon_400x400.jpg","width":"100","tags":"Hypermedia"},{"id":"125","name":"Fortune.js","summary":"Hello nerds. Fortune is a framework for prototyping hypermedia APIs that implement the JSON API specification. It comes with a modular persistence layer, with adapters for NeDB (built-in), MongoDB, MySQL, Postgres, &amp; SQLite. See guide for how to use.","details":"Hello nerds. Fortune is a framework for prototyping hypermedia APIs that implement the JSON API specification. It comes with a modular persistence layer, with adapters for NeDB (built-in), MongoDB, MySQL, Postgres, &amp; SQLite. See guide for how to use.","website":"http:\/\/fortunejs.com\/","logo":"http:\/\/kinlane-productions.s3.amazonaws.com\/api-evangelist-site\/blog\/fortune-js-logo-2.png","width":"100","tags":"Hypermedia"},{"id":"153","name":"HAL","summary":"HAL is a simple format that gives a consistent and easy way to hyperlink between resources in your API. Adopting HAL will make your API explorable, and its documentation easily discoverable from within the API itself. In short, it will make your API easier to work with and therefore more attractive to client developers. APIs that adopt HAL can be easily served and consumed using open source librar","details":"HAL is a simple format that gives a consistent and easy way to hyperlink between resources in your API. Adopting HAL will make your API explorable, and its documentation easily discoverable from within the API itself. In short, it will make your API easier to work with and therefore more attractive to client developers. APIs that adopt HAL can be easily served and consumed using open source libraries available for most major programming languages. It's also simple enough that you can just deal with it as you would any other JSON.","website":"http:\/\/stateless.co\/hal_specification.html","logo":"http:\/\/kinlane-productions.s3.amazonaws.com\/api-evangelist-site\/blog\/bw-github.jpg","width":"100","tags":"Hypermedia"},{"id":"126","name":"HAL Browser","summary":"An API browser for the hal+json media type.HAL is a simple format that gives a consistent and easy way to hyperlink between resources in your API. Adopting HAL will make your API explorable, and its documentation easily disocverable from within the API itself.","details":"An API browser for the hal+json media type.HAL is a simple format that gives a consistent and easy way to hyperlink between resources in your API. Adopting HAL will make your API explorable, and its documentation easily disocverable from within the API itself.","website":"https:\/\/github.com\/mikekelly\/hal-browser","logo":"http:\/\/kinlane-productions.s3.amazonaws.com\/api-evangelist-site\/blog\/hal-info-model.png","width":"100","tags":"Hypermedia"},{"id":"156","name":"JSON:API","summary":"A standard for building APIs in JSON, extracted from the JSON transport implicitly defined by Ember Data's REST adapter.","details":"A standard for building APIs in JSON, extracted from the JSON transport implicitly defined by Ember Data's REST adapter.","website":"","logo":"http:\/\/kinlane-productions.s3.amazonaws.com\/api-evangelist-site\/blog\/jsonapi@1.3x.png","width":"150","tags":"Hypermedia"},{"id":"127","name":"Roar","summary":"Roar is a framework for parsing and rendering REST documents. Representers let you define your API document structure and semantics. They allow both rendering representations from your modelsandparsing documents to update your Ruby objects. The bi-directional nature of representers make them interesting for both server and client usage. Roar comes with built-in JSON, JSON-HAL and XML support. Its ","details":"Roar is a framework for parsing and rendering REST documents. Representers let you define your API document structure and semantics. They allow both rendering representations from your modelsandparsing documents to update your Ruby objects. The bi-directional nature of representers make them interesting for both server and client usage. Roar comes with built-in JSON, JSON-HAL and XML support. Its highly modulare architecture provides features like coercion, hypermedia, HTTP transport, client caching and more.","website":"https:\/\/github.com\/apotonick\/roar","logo":"http:\/\/kinlane-productions.s3.amazonaws.com\/api-evangelist-site\/blog\/bw-github.jpg","width":"100","tags":"Hypermedia"},{"id":"154","name":"UBER","summary":"The Uber message format is a minimal read\/write hypermedia type designed to support simple state transfers and ad-hoc hypermedia-based transitions. This document describes both the XML and JSON variants of the format and provides guidelines for supporting Uber messages over the HTTP protocol.","details":"The Uber message format is a minimal read\/write hypermedia type designed to support simple state transfers and ad-hoc hypermedia-based transitions. This document describes both the XML and JSON variants of the format and provides guidelines for supporting Uber messages over the HTTP protocol.","website":"https:\/\/rawgit.com\/mamund\/media-types\/master\/uber-hypermedia.html","logo":"http:\/\/kinlane-productions.s3.amazonaws.com\/api-evangelist-site\/blog\/madmen_icon_400x400.jpg","width":"100","tags":"Hypermedia"}],"published":"11\/06\/2014"}